{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap e29ead99e5076e9ddb58","webpack:///./~/uuid/index.js","webpack:///./src/layer.js","webpack:///./src/neuron.js","webpack:///./~/uuid/lib/bytesToUuid.js","webpack:///./~/uuid/lib/rng-browser.js","webpack:///./src/neural-js.js","webpack:///./src/network.js","webpack:///./~/uuid/v1.js","webpack:///./~/uuid/v4.js","webpack:///(webpack)/buildin/global.js"],"names":["Layer","options","id","v4","metadata","neurons","_init","Object","assign","activationFunction","autoPopulateNeurons","size","_validateOrThrow","Array","from","length","map","push","Error","isArray","nextLayer","neuron","nextLayerNeuron","inputNeuronIds","includes","addOutputNeuronId","outputNeuronIds","addInputNeuronId","input","i","process","n","toJSON","Neuron","weight","Math","random","bias","lastComputedOutput","result","normalizedResult","normalize","value","pow","E","Network","layers","autoPopulateLayer","inputLayer","hiddenLayer","outputLayer","layer","connectInputOutputNeurons","set","learningRate","iterations","error","log","layersCopy","reverse","pop","iteration","data","resolve","l"],"mappings":"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","file":"neural-js.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"neural-js\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"neural-js\"] = factory();\n\telse\n\t\troot[\"neural-js\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 10);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap e29ead99e5076e9ddb58","var v1 = require('./v1');\nvar v4 = require('./v4');\n\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\n\nmodule.exports = uuid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/uuid/index.js\n// module id = 0\n// module chunks = 0","import uuid from 'uuid';\n\nimport Neuron from './neuron';\n\n/**\n * @class Layer\n * @description Layer object than contains all neurons.\n */\nexport default class Layer {\n    constructor(options = {}) {\n        this.id = uuid.v4();\n        this.metadata = {};\n        this.neurons = [];\n\n        this._init(options);\n    }\n\n    /**\n     * Initialize layer with neurons pass in options or auto generated.\n     * @param {object} options Parameters\n     * @param {boolean} [options.autoPopulateNeurons = true]  If it's true, generate 10 neurons according to the next parameter\n     * @param {number} [options.size = 10] The maximum number of neurons in the layer\n     * @param {Array} [options.neurons = null] All the neurons to add in the layer\n     * @param {string} [options.activationFunction = 'sigmoid'] The layer activation function\n     * @private\n     */\n    _init(options) {\n        options = Object.assign({\n            activationFunction: 'sigmoid',\n            autoPopulateNeurons: true,\n            size: 10,\n            neurons: null\n        }, options);\n\n        this._validateOrThrow(options);\n        this.metadata.options = options;\n\n        if (options.autoPopulateNeurons) {\n            this.neurons = Array.from({ length: options.size }).map(() => new Neuron({\n                activationFunction: options.activationFunction\n            }));\n        } else {\n            this.neurons.push(...options.neurons);\n        }\n    }\n\n    /**\n     * Validate options object and throw if a value doesn't respect a condition.\n     * @param {object} options Parameters to validate\n     * @param {boolean} options.autoPopulateNeurons If it's true, generate 10 neurons according to the next parameter\n     * @param {number} options.size The maximum number of neurons in the layer\n     * @param {Array} options.neurons All the neurons to add in the layer\n     * @param {string} options.activationFunction The layer activation function\n     * @private\n     */\n    _validateOrThrow(options) {\n        if (typeof options.autoPopulateNeurons !== 'boolean') throw new Error('autoPopulateNeurons must be a boolean.');\n        if (typeof options.size !== 'number') throw new Error('size must be a number.');\n        if (typeof options.activationFunction !== 'string') throw new Error('activationFunction must be a string.');\n        if (!options.autoPopulateNeurons && !Array.isArray(options.neurons)) throw new Error('neurons must be an array.');\n    }\n\n    /**\n     * Add new input connection on each neuron of the new layer and output connection on each neuron contains in the actual layer.\n     * @param {Layer} nextLayer The layer on\n     */\n    connectInputOutputNeurons(nextLayer) {\n        for (const neuron of this.neurons) {\n            for (const nextLayerNeuron of nextLayer.neurons) {\n                !neuron.metadata.inputNeuronIds.includes(nextLayer.id) && neuron.addOutputNeuronId(nextLayerNeuron.id);\n                !nextLayerNeuron.metadata.outputNeuronIds.includes(neuron.id) && nextLayerNeuron.addInputNeuronId(neuron.id);\n            }\n        }\n    }\n\n    resolve(input) {\n        return this.neurons.map((neuron, i) => neuron.process(input[i]));\n    }\n\n    /**\n     * Return the layer as a json object.\n     * @returns {{id: *, metadata: ({}|*), neurons: Array}}\n     */\n    toJSON() {\n        return {\n            id: this.id,\n            metadata: this.metadata,\n            neurons: this.neurons.map(n => n.toJSON())\n        };\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/layer.js","import uuid from 'uuid';\n\n/**\n * @class Neuron\n * @description Neuron object than contains weight, bias, ... information to compute the prediction.\n */\nexport default class Neuron {\n    constructor(options = { activationFunction: 'sigmoid' }) {\n        this.id = uuid.v4();\n        this.metadata = {\n            inputNeuronIds: [],\n            outputNeuronIds: []\n        };\n        this.weight = Math.random();\n        this.bias = 1;\n        this.activationFunction = options.activationFunction;\n        this.lastComputedOutput = null;\n    }\n\n    /**\n     * Add the id of the input neuron.\n     * @param {number} id The id of the neuron\n     */\n    addInputNeuronId(id) {\n        this.metadata.inputNeuronIds.push(id);\n    }\n\n    /**\n     * Add the id of the output neuron.\n     * @param {number} id The id of the neuron\n     */\n    addOutputNeuronId(id) {\n        this.metadata.outputNeuronIds.push(id);\n    }\n\n    /**\n     * Compute de output value.\n     * @param {Array} inputs All inputs value\n     * @returns {number}\n     */\n    process(input) {\n        const result = input * this.weight;\n        const normalizedResult = this.normalize(result);\n        this.lastComputedOutput = normalizedResult;\n        return this.lastComputedOutput;\n    }\n\n    normalize(value) {\n        switch (this.activationFunction) {\n            case 'sigmoid':\n                return (1 - (Math.pow(Math.E, -value)));\n            default:\n                throw new Error(`The activationFunction ${this.activationFunction} isn't implemented.`);\n        }\n    }\n\n    /**\n     * Return the layer as a json object.\n     * @returns {{id: *, metadata: ({}|*), weight: *, bias: *, inputNeuronIds: Array, outputNeuronIds: *}}\n     */\n    toJSON() {\n        return {\n            id: this.id,\n            metadata: this.metadata,\n            weight: this.weight,\n            bias: this.bias\n        };\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/neuron.js","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  return  bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\nmodule.exports = bytesToUuid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/uuid/lib/bytesToUuid.js\n// module id = 3\n// module chunks = 0","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\nvar rng;\n\nvar crypto = global.crypto || global.msCrypto; // for IE 11\nif (crypto && crypto.getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16);\n  rng = function whatwgRNG() {\n    crypto.getRandomValues(rnds8);\n    return rnds8;\n  };\n}\n\nif (!rng) {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var  rnds = new Array(16);\n  rng = function() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n\nmodule.exports = rng;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/uuid/lib/rng-browser.js\n// module id = 4\n// module chunks = 0","import Neuron from './neuron';\nimport Layer from './layer';\nimport Network from './network';\n\nexport default { Network, Layer, Neuron };\n\n\n\n// WEBPACK FOOTER //\n// ./src/neural-js.js","import uuid from 'uuid';\n\nimport Layer from './layer';\n\n/**\n * @class Network\n * @description Network object than contains all layers, with minimum two layers (input and output).\n */\nexport default class Network {\n    constructor(options = {}) {\n        this.id = uuid.v4();\n        this.metadata = {};\n        this.layers = [];\n\n        this._init(options);\n    }\n\n    /**\n     * Initialize the network with layers pass in options or auto generated.\n     * @param {object} options Parameters\n     * @param {string} [options.activationFunction = 'sigmoid'] The layer activation function\n     * @param {boolean} [options.autoPopulateLayer = true]  If it's true, generate 3 layers (input, hidden, output)\n     * @param {number} [options.layers = []] The layers pass to populate the network\n     * @private\n     */\n    _init(options) {\n        options = Object.assign({\n            activationFunction: 'sigmoid',\n            autoPopulateLayer: true,\n            layers: null\n        }, options);\n\n        this._validateOrThrow(options);\n        this.metadata.options = options;\n\n        if (options.autoPopulateLayer) {\n            const inputLayer = new Layer({ size: 100, activationFunction: options.activationFunction });\n            const hiddenLayer = new Layer({ size: 10, activationFunction: options.activationFunction });\n            const outputLayer = new Layer({ size: 1, activationFunction: options.activationFunction });\n\n            this.layers.push(inputLayer, hiddenLayer, outputLayer);\n            this.layers.map((layer, i) => i < this.layers.length - 1 && layer.connectInputOutputNeurons(this.layers[i + 1]));\n        } else {\n            this.layers.push(...options.layers);\n        }\n    }\n\n    /**\n     * Validate options object and throw if a value doesn't respect a condition.\n     * @param {object} options Parameters\n     * @param {boolean} options.autoPopulateLayer  If it's true, generate 3 layers (input, hidden, output)\n     * @param {number} options.layers The layers pass to populate the network\n     * @param {string} options.activationFunction The layer activation function\n     * @private\n     */\n    _validateOrThrow(options) {\n        if (typeof options.autoPopulateLayer !== 'boolean') throw new Error('autoPopulateLayer must be a boolean.');\n        if (typeof options.activationFunction !== 'string') throw new Error('activationFunction must be a string.');\n        if (!options.autoPopulateLayer && !Array.isArray(options.layers)) throw new Error('layers must be an array.');\n        if (!options.autoPopulateLayer && !options.layers.length < 2) throw new Error('The network waiting for 2 layers minimum (input, output).');\n    }\n\n    /**\n     *\n     * @param data\n     */\n    train(set, options = {}) {\n        options = Object.assign({\n            learningRate: 0.1,\n            iterations: 10000,\n            error: 0.005,\n            log: false\n        }, options);\n\n        const layersCopy = Array.from(this.layers);\n        const inputLayer = layersCopy.reverse().pop();\n        //const outputLayer = layersCopy.reverse().pop();\n        //const hiddenLayers = [].concat(...layersCopy);\n\n        let iteration = 0;\n        let error = 1;\n\n        while (iteration <= options.iterations || error > options.error) {\n            iteration++;\n            for (const data of set) {\n                let input = data.input;\n                inputLayer.resolve(input);\n            }\n        }\n    }\n\n    propagate() {\n\n    }\n\n    /**\n     * Return the network as json object.\n     * @returns {{id: *, metadata: ({}|*), layers: Array}}\n     */\n    toJSON() {\n        return {\n            id: this.id,\n            metadata: this.metadata,\n            layers: this.layers.map(l => l.toJSON()),\n            activationFunction: this.activationFunction\n        };\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/network.js","// Unique ID creation requires a high quality random # generator.  We feature\n// detect to determine the best RNG source, normalizing to a function that\n// returns 128-bits of randomness, since that's what's usually required\nvar rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\n// random #'s we need to init node and clockseq\nvar _seedBytes = rng();\n\n// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\nvar _nodeId = [\n  _seedBytes[0] | 0x01,\n  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n];\n\n// Per 4.2.2, randomize (14 bit) clockseq\nvar _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n// Previous uuid creation time\nvar _lastMSecs = 0, _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  var node = options.node || _nodeId;\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/uuid/v1.js\n// module id = 7\n// module chunks = 0","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options == 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/uuid/v4.js\n// module id = 8\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 9\n// module chunks = 0"],"sourceRoot":""}